---
title: Untity学习记录-2D平台跳跃游戏-05-编写地面移动代码：让你的角色动起来！
published: 2025-03-16
tags: ['Unity','游戏']
description: 学习Unity
image: https://cdn.jsdelivr.net/gh/Flandre923/CDN@latest/img/20250316134318.png
category: Unity
draft: false
---
# 编写地面移动代码：让你的角色动起来！

## 写代码前的温馨提示

在开始写代码之前，我想跟小伙伴们说一件事：那就是无论你怎样写这个代码，都没有对错之分。只要能够成功运行，并且结果是好的，那就是对的。只不过通过我们不断的学习，可以让代码变得更优化。所以小伙伴们不要觉得只有跟我写的完全一样才是对的，我只是提供一个思路和一个实践出来的方法。你可以根据你的经验和你的想法写出更好的代码。所以如果你有好的方法，请留言让我跟更多的朋友可以学习。同时也请继续包容我的错误，谢谢大家！

## 开始编写地面移动代码

那我们开始写这个代码吧！首先我们去到我们的 Scripts 文件夹，然后在空白的位置，我们给它起名叫 PlayerMovement。然后我们将这个 PlayerMovement 拖拽放到我们这个主角 Robbie 的身上。双击打开我们的 VS，我们开始写我们的代码。

首先我们就要获得的就是我们的 Rigidbody，所以我在一开始要来获得我们的 Rigidbody。所以在 Start 这个位置，我们要一开始获得 Rigidbody 的 Component。已经做过上一个系列的小伙伴们应该非常熟悉这个流程了，对吗？

然后我们要来设置一些参数。在这里，从今天开始，我希望我们大家可以一起努力，把我代码写的更加的规范更整洁，而且更容易让别人来阅读。所以我们要来一开始就整理好我们的这个代码。所以我在前面加上一个 Header，我们要来先来添加一些移动的参数，所以我在这里写上中文移动参数。

第一个就是要来 Public 我们的 Speed，我们角色的移动速度，我做一个 float，我要给它一个初始值（8f）。然后今天我们要解决在地面移动也包括下蹲的移动，所以我希望它在下蹲的时候速度可以有一些减缓，所以我设定一个参数，用来控制它减慢的速率，所以我再另外做一个 float，叫做 crouchSpeedDivisor，就是在它下蹲的时候速度所除以的那个基数，那我给它设置为一个 3f。

然后我们需要来设置一个变量，这里我希望这个变量不是公开的，不是被其它的代码可以读取的，只在我们当前代码来用，所以我省略了前面的这个 Private 就可以直接这样写，我希望它叫做 xVelocity，意思就是来判断它 X 轴的力的方向。

所以接下来我们来写这个代码了。那首先因为我们要设置到用 Rigidbody 考虑刚体的力的速度，所以我们需要 FixedUpdate。然后我们要来生成我们自己的函数叫做 GroundMovement 地上的移动。

那么首先在地上的移动的时候，我们要来先判断左右的移动了。刚才我设置的这个 xVelocity，我们先来给它一个副职 X 的 Velocity，我让它可以获得我在键盘上输入的左右的移动，所以是 Input.GetAxis("Horizontal")，你已经做过这个第一个系列游戏的小伙伴们已经知道了，这里面的它的数值是介于负 1 到 1 之间的浮点型，所以包括 0.0 几，你是一个很小的数值。

然后我们就要给它移动了，rb.velocity 等于 new Vector2，X 轴的方向乘以我们刚才设置的这个速度，然后 Y 轴保持不变。好的那我们保存我们的代码，上去进行调用保存回到 Unity 当中，我们试一试。我们点击 Play，然后这个时候按下键盘上的 A 和 D，我们就可以成功将我们的角色进行移动了，然后按下键盘左和右也可以了。

小伙伴们可能会觉得，诶？这为什么我添加了一个 0 摩擦力的这个材质，它没有进行滑动的效果，反而走得很稳的原因，就是因为我们刚才设置的这个参数 X 的 Velocity 这个值是会在你不按键盘的时候归“0”的，所以如果你不按键盘，它的默认值就是“0”，所以当它速度是“0”的时候，它就会站立不动，所以它不会出现滑动的效果。

然后我们有了移动之后，接下来我们希望游戏角色在移动的过程中可以进行画面的翻转，就是它有面向左和面向右。所以这里面，我要来单独写一个函数，所以我们设一个新的函数叫 FilpDirction，所以我来判断一下，如果刚才我们的 X 轴的速度小于 0，这个时候我的 transform.localScale 等于 new Vector2 (-1, 1);，所以它速度小于 0 的时候就代表它现在向左移动，所以我们要翻转我们的游戏角色，它的 X 值变成负 1。

小伙伴可能会疑问了，为什么在这里，我没有写大括号，如果你的 if 判断语句里面只包括一行代码的话，我们可以忽略这个大话号不写，这样的话会节省你的空间，看起来会比较整洁。那么另外我们也要判断，如果这个 X 的 Velocity 大于 0，那么我们的 transform 就要改变，我将它直接复制粘贴过来，再变回 1，保存好以后，我们回到游戏当中试一下，千万别忘记写完了函数之后要在我们的代码当中去调用它，所以我把它放在 GroundMovement 里面去判断移动速度，然后翻转保存回到 Unity 当中，我们试一下，看我移动左右的时候，我的人物可以进行翻转了。

接下来我们要做的是什么的？我们就来做这个下蹲有关的，那么在做这个下蹲有关，在这个操作的时候，我们要留意我们的系统，默认是没有下蹲的这个按键的，我们的项目设置在里面，我们找到 Input 这一项，在 Input 当中可以看到我们现在没有 Crouch 下蹲的这个操作，所以我们用以前的方法在这个 Jump 跳跃的这个位置，按鼠标右键鼠标，右键之后我们选择 Duplicate Array Element 就是复制这个操作，复制之后，我们将另外一个 Jump 给它改名字叫做 Crouch，小伙伴们要记住你改的这个名字，留意它的大小写，然后我们要改下它的按键，我们改成 Positive Button，给它一个是 S，所以按下 S 的时候，它会下蹲。好的保存我们的 Untiy，接下来我们回到代码中来写我们的下蹲。

首先在做下蹲的时候，我希望我的系统能够判断我现在是否是下蹲的状态，所以我同样来生成一个变量来判断我的游戏角色的各种状态，因为接下来我们还要做会做其它的状态，比如说悬挂在空中，还有跳跃、下蹲、是否在地面，所以我们重新给它一个分类用 [Header] 区分开，我们给它起个名字，叫做状态，在状态里，我们创建一个布尔型叫做 isCrouch，就代表它正在下蹲。

那么接下来我们来写这个下蹲有关的事情了。首先，我们要来单独写两个函数，第一个就是 Crouch，所以我们另外创建一个函数，Crouch，另外，我们还需要另外一个还记得吗，我之前我在做小狐狸的游戏的时候，我们的狐狸在穿越障碍物之后是否能够自动起立的问题上，我们反复修改了几次，所以在这里我们直接避免这个问题是出现，我们另外做一个函数，叫做 StandUp。

好的，然后我们要来一开始来判断一下，在我的游戏角色能够移动之前，我就希望它优先判断我现在是否是下蹲的状态，这会直接影响我的移动的速度，所以我在一开始要判断 if，如果我按下了下蹲的这个按键，那么现在我要运行下蹲的这个函数，如果按下了这个按键之后我就要运行刚才我写好的这个函数，我将它复制粘贴过来。

另外，如果，我们来判断一下，我希望它在下蹲的状态的时候判断我这个键子没有按下的时候就让它自动起立，所以我们判断如果不是 Input.GetButton，同时，我还是在 Crouch 的状态，那么我就要站立起来，所以看到这个值的重要性了，就是在它一开始默认的情况下，它的默认值是 false，所以判断如果它是在下蹲的情况，这个值如果是 true 的话，同时我并没有按下下蹲的键它就应该自动起立。

那在这两个函数当中，我们一开始就要将我最开始的这个 isCrouch 进行赋值，所以在下蹲的函数里，Crouch 就应该等于 true，而在 StandUp 里面，我们就要将它改回来。

所以我们刚才设置了另外一个参数，就是在下蹲的时候，它的速度会有所减少，所以在这里面，我们也要改变它的速度。那么我们一开始获得了 X 轴的移动方向，之后在它没有开始移动之前，我们就要来调整它的速度了，如果是下蹲，我应该有个新速度，如果不是下蹲状态，我应该维持原来的不变，所以我们要判断，如果现在是 Crouch 的态度，那么我的 X 轴的 Velocity 就应该除以刚才我们设置的这个参数。

好的小伙伴们请留意代码，当中我们是有它的执行的顺序的，所以我们要优先考虑我们下蹲的这个状态，才可以在它移动之前就改变它的速度。

然后接下来我们要做什么呢，我们现在这个 Crouch 还有 StandUp，是没有具体的，实际的效果的，只是改变了一个布尔值的参数，接下来我们希望做的是，当我按下下蹲按键的时候，我们的这个游戏角色的这个 Collider 会减半，这样的话我们就可以穿过我们游戏当中的这些障碍物，最小伙伴们还记得吗，之前我们将这个 Robbie 的 BoxCollider，设置了一个固定的值，所以接下来我们要来调整一下这个值。

那么首先我要先获得这个 Collider 的 Component，所以我在一开始我们要来获得它，但是在这里请小伙伴们要留意，以前我们会直接用 Collider2D 来获得它的所有的 Collider，但这里我们要特别使用 BoxCollider2D，为什么要这么做呢？如果我没有在前面添加 Box，那么 Collider2D 代表它所有的 Collider，无论是方形还是圆形代表它是一个整体所有的 Collider，但是如果我做 Box 的话，那么我们专属针对于这个 BoxCollider 的这样，我们才可以设置它的这些参数，我们可以看到我的 BoxCollider 里有两个参数，一个是 Offset 就是它的位置，另外就是它的 size 就是它的尺寸，我们要修改这两个参数。

那接下来我们在 Start 这边，我们就要一开始来获得它，我的 Collider 就是 GetComponent，Collider2D，我希望按下下蹲的时候，我的原有的尺寸会减半，那我至少要先保留它的原有尺寸，然后再获得一个减半的尺寸，所以按键我就获得减半了，不按键 StandUp 我就获得原来的尺寸，在这个时候我们要生成几个变量，这几个变量是用来接收我的碰撞体的，尺寸的，所以，我做一个脚注 // 碰撞体的尺寸，碰撞体的尺寸是有 X 和 Y 两个值的，所以代表它是一个二维的变量，那么我用 Vector2 来创建这几个变量，所以我要先获得它站立的情况下的尺寸和下蹲的尺寸，所以我先获得站立的尺寸，然后我要获得它站立时的坐标，同样我也要定义一个变量，就是它大下蹲的时候，以及下蹲的时候，它的位置。

好有了这些变量之后，接下来我们来看看怎么来用，我们要在一开始就获得我原有的这个方形的碰撞体的尺寸，这样才能保护我们原来的尺寸不被更改，然后我们要在 Start 里面先来获得它，我们要来先来找它的站立的时候的，完整的碰撞体的尺寸，那么应该等于我们方形碰撞体的点儿，size，同样它的位置也是等于它的 Offset 是不是非常的方便。

如果小伙伴们将这个位置不是使用的 BoxCollider，而是使用的 Collider 的话，那么我们不能用 .size 和 .offset 来访问这两个参数的，请小伙伴们留意这个部分，然后我们还需要获得它下蹲的时候的尺寸，下蹲的时候尺寸，我们希望我们的游戏角色的这个碰撞体 Y 轴减半就可以了，所以我们要在一开始 Start 里就把它写好，请小伙伴们留意这里，我是要给它添加一个全新的尺寸的变量，而不是原有的尺寸变量，所以我要在这里用 new Vector2 来进行赋值，所以它的 X 轴是没有变化的，但是 Y 值得会除以 2f，另外，请留意这里不要写错了，在这里我们也同样使用原有碰撞体的 offset 千万要区分开跟这个 size。

好的我们写好了这个部分之后，接下来我们来丰富一下我们的 Crouch 和 StandUp 两个函数，所以当它下蹲的时候，我的现有的碰撞，尺寸就要改成蹲下的时候的尺寸，同样现有的 offset 也要改成蹲下的 offset，那么站立的时候，我们就要恢复原有的站立的尺寸。

好的我们写好了么，这代码了，小伙伴们你看明白了这段代码的意思了嘛，所以我们保存了原有的尺寸，然后也做了一个除以 2f 的尺寸，所以我只要在下蹲和站立的时候来切换，这两个尺寸就可以达到我们想要的效果了，所以回到游戏中试玩一下，好的这个时候，我们选中我们的 Robbie，然后我们打开我们的 BoxCollider，这个时候我们就可以看见我们的 Collider 样子了，然后我们可以左右进行移动，然后当我按下的时候，请小伙伴们注意它的 Collider 变化，看到了吧，它的 Collider 下移了，然后我们就可以通过障碍物了，同时，当我摁住下的时候，我的游戏角色的移动速度也变慢了，所以小伙伴们如果你希望这个下蹲的时候移动速度更慢的话，你可以在 Inspector 的窗口里来修改这个参数。

好的小伙伴们，那我们现在还没有考虑在判断 Crouch 的状态下，如果头上有障碍物，我是不能起立的，所以现在我还没有考虑，但是稍后我们会一起做的，先别着急\~，那么这个视频我们就讲解了所有在地面上的移动了，谢谢所有点赞和三连的小伙伴们的支持！，特别感谢那些为我充电的朋友们！，谢谢你们视频结束后也会有充电感谢的界面！，那我们下个视频再见吧，拜拜！大家好，我是 Michael。

从这个视频开始我们要来写代码了，那么今天我们要解决的是，一些地面移动有关的代码。在开始写代码之前想跟小伙伴们说一件事，那就是无论你怎样写这个代码，都没有对错之分，只要能够成功运行，并且结果是好的，那就是对的，只不过通过我们不断的学习可以让代码变得更优化，所以小伙伴们不要觉得只有跟我写的完全一样才是对的，我只是提供一个思路和一个实践出来的方法，你可以根据你的经验和你的想法写出更好的代码，所以如果你有好的方法，请留言让我跟更多的朋友可以学习，同时也请继续包容我的错误，谢谢大家，那我们开始写这个代码吧，首先我们去到我们的 Scripts 的文件夹，然后在空白的位置，我们给它起名叫 PlayerMovement，然后我们将这个 PlayerMovement 拖拽放到我们这个主角 Robbie 的身上，双击打开我们的 VS 我们开始写我们的代码，首先我们就要获得的就是我们的 Rigidbody，所以我在一开始要来获得我们的 Rigidbody。所以在 Start 这个位置，我们要一开始获得 Rigidbody 的 Component，已经做过上一个系列的小伙伴们应该非常熟悉这个流程了，对吗，然后我们要来设置一些参数，在这里，从今天开始，我希望我们大家可以一起努力，把我代码写的更加的规范更整洁，而且更容易让别人来阅读，所以我们要来一开始就整理好我们的这个代码，所以我在前面加上一个 Header，我们要来先来添加一些移动的参数，所以我在这里写上中文移动参数，第一个就是要来 Public 我们的 Speed 我们角色的移动速度，我做一个 float，我要给它一个初始值（8f），然后今天我们要解决在地面移动也包括下蹲的移动，所以我希望它在下蹲的时候速度可以有一些减缓，所以我设定一个参数，用来控制它减慢的速率，所以我再另外做一个 float，叫做 crouchSpeedDivisor，就是在它下蹲的时候速度所除以的那个基数，那我给它设置为一个 3f，然后我们需要来设置一个变量，这里我希望这个变量不是公开的，不是被其它的代码可以读取的，只在我们当前代码来用，所以我省略了前面的这个 Private 就可以直接这样写，我希望它叫做 xVelocity，意思就是来判断它 X 轴的力的方向，所以接下来我们来写这个代码了，那首先因为我们要设置到用 Rigidbody 考虑刚体的力的速度，所以我们需要 FixedUpdate，然后我们要来生成我们自己的函数叫做 GroundMovement 地上的移动，那么首先在地上的移动的时候，我们要来先判断左右的移动了，刚才我设置的这个 xVelocity，我们先来给它一个副职 X 的 Velocity，我让它可以获得我在键盘上输入的左右的移动，所以是 Input.GetAxis("Horizontal")，你已经做过这个第一个系列游戏的小伙伴们已经知道了，这里面的它的数值是介于负 1 到 1 之间的浮点型，所以包括 0.0 几，你是一个很小的数值，然后我们就要给它移动了，rb.velocity 等于 new Vector2，X 轴的方向乘以我们刚才设置的这个速度，然后 Y 轴保持不变，好的那我们保存我们的代码，上去进行调用保存回到 Unity 当中，我们试一试，我们点击 Play，然后这个时候按下键盘上的 A 和 D，我们就可以成功将我们的角色进行移动了，然后按下键盘左和右也可以了，小伙伴们可能会觉得，诶？这为什么我添加了一个 0 摩擦力的这个材质，它没有进行滑动的效果，反而走得很稳的原因，就是因为我们刚才设置的这个参数 X 的 Velocity 这个值是会在你不按键盘的时候归“0”的，所以如果你不按键盘，它的默认值就是“0”，所以当它速度是“0”的时候，它就会站立不动，所以它不会出现滑动的效果，然后我们有了移动之后，接下来我们希望游戏角色在移动的过程中可以进行画面的翻转，就是它有面向左和面向右。所以这里面，我要来单独写一个函数，所以我们设一个新的函数叫 FilpDirction，所以我来判断一下，如果刚才我们的 X 轴的速度小于 0，这个时候我的 transform.localScale 等于 new Vector2 (-1, 1);，所以它速度小于 0 的时候就代表它现在向左移动，所以我们要翻转我们的游戏角色，它的 X 值变成负 1。小伙伴可能会疑问了，为什么在这里，我没有写大括号，如果你的 if 判断语句里面只包括一行代码的话，我们可以忽略这个大话号不写，这样的话会节省你的空间，看起来会比较整洁。那么另外我们也要判断，如果这个 X 的 Velocity 大于 0，那么我们的 transform 就要改变，我将它直接复制粘贴过来，再变回 1，保存好以后，我们回到游戏当中试一下，千万别忘记写完了函数之后要在我们的代码当中去调用它，所以我把它放在 GroundMovement 里面去判断移动速度，然后翻转保存回到 Unity 当中，我们试一下，看我移动左右的时候，我的人物可以进行翻转了，接下来我们要做的是什么的？我们就来做这个下蹲有关的，那么在做这个下蹲有关，在这个操作的时候，我们要留意我们的系统，默认是没有下蹲的这个按键的，我们的项目设置在里面，我们找到 Input 这一项，在 Input 当中可以看到我们现在没有 Crouch 下蹲的这个操作，所以我们用以前的方法在这个 Jump 跳跃的这个位置，按鼠标右键鼠标，右键之后我们选择 Duplicate Array Element 就是复制这个操作，复制之后，我们将另外一个 Jump 给它改名字叫做 Crouch，小伙伴们要记住你改的这个名字，留意它的大小写，然后我们要改下它的按键，我们改成 Positive Button，给它一个是 S，所以按下 S 的时候，它会下蹲。好的保存我们的 Untiy，接下来我们回到代码中来写我们的下蹲。

首先在做下蹲的时候，我希望我的系统能够判断我现在是否是下蹲的状态，所以我同样来生成一个变量来判断我的游戏角色的各种状态，因为接下来我们还要做会做其它的状态，比如说悬挂在空中，还有跳跃、下蹲、是否在地面，所以我们重新给它一个分类用 [Header] 区分开，我们给它起个名字，叫做状态，在状态里，我们创建一个布尔型叫做 isCrouch，就代表它正在下蹲。

那么接下来我们来写这个下蹲有关的事情了。首先，我们要来单独写两个函数，第一个就是 Crouch，所以我们另外创建一个函数，Crouch，另外，我们还需要另外一个还记得吗，我之前我在做小狐狸的游戏的时候，我们的狐狸在穿越障碍物之后是否能够自动起立的问题上，我们反复修改了几次，所以在这里我们直接避免这个问题是出现，我们另外做一个函数，叫做 StandUp。

好的，然后我们要来一开始来判断一下，在我的游戏角色能够移动之前，我就希望它优先判断我现在是否是下蹲的状态，这会直接影响我的移动的速度，所以我在一开始要判断 if，如果我按下了下蹲的这个按键，那么现在我要运行下蹲的这个函数，如果按下了这个按键之后我就要运行刚才我写好的这个函数，我将它复制粘贴过来。

另外，如果，我们来判断一下，我希望它在下蹲的状态的时候判断我这个键子没有按下的时候就让它自动起立，所以我们判断如果不是 Input.GetButton，同时，我还是在 Crouch 的状态，那么我就要站立起来，所以看到这个值的重要性了，就是在它一开始默认的情况下，它的默认值是 false，所以判断如果它是在下蹲的情况，这个值如果是 true 的话，同时我并没有按下下蹲的键它就应该自动起立。

那在这两个函数当中，我们一开始就要将我最开始的这个 isCrouch 进行赋值，所以在下蹲的函数里，Crouch 就应该等于 true，而在 StandUp 里面，我们就要将它改回来。

所以我们刚才设置了另外一个参数，就是在下蹲的时候，它的速度会有所减少，所以在这里面，我们也要改变它的速度。那么我们一开始获得了 X 轴的移动方向，之后在它没有开始移动之前，我们就要来调整它的速度了，如果是下蹲，我应该有个新速度，如果不是下蹲状态，我应该维持原来的不变，所以我们要判断，如果现在是 Crouch 的态度，那么我的 X 轴的 Velocity 就应该除以刚才我们设置的这个参数。

好的小伙伴们请留意代码，当中我们是有它的执行的顺序的，所以我们要优先考虑我们下蹲的这个状态，才可以在它移动之前就改变它的速度。

然后接下来我们要做什么呢，我们现在这个 Crouch 还有 StandUp，是没有具体的，实际的效果的，只是改变了一个布尔值的参数，接下来我们希望做的是，当我按下下蹲按键的时候，我们的这个游戏角色的这个 Collider 会减半，这样的话我们就可以穿过我们游戏当中的这些障碍物，最小伙伴们还记得吗，之前我们将这个 Robbie 的 BoxCollider，设置了一个固定的值，所以接下来我们要来调整一下这个值。

那么首先我要先获得这个 Collider 的 Component，所以我在一开始我们要来获得它，但是在这里请小伙伴们要留意，以前我们会直接用 Collider2D 来获得它的所有的 Collider，但这里我们要特别使用 BoxCollider2D，为什么要这么做呢？如果我没有在前面添加 Box，那么 Collider2D 代表它所有的 Collider，无论是方形还是圆形代表它是一个整体所有的 Collider，但是如果我做 Box 的话，那么我们专属针对于这个 BoxCollider 的这样，我们才可以设置它的这些参数，我们可以看到我的 BoxCollider 里有两个参数，一个是 Offset 就是它的位置，另外就是它的 size 就是它的尺寸，我们要修改这两个参数。

那接下来我们在 Start 这边，我们就要一开始来获得它，我的 Collider 就是 GetComponent，Collider2D，我希望按下下蹲的时候，我的原有的尺寸会减半，那我至少要先保留它的原有尺寸，然后再获得一个减半的尺寸，所以按键我就获得减半了，不按键 StandUp 我就获得原来的尺寸，在这个时候我们要生成几个变量，这几个变量是用来接收我的碰撞体的，尺寸的，所以，我做一个脚注 // 碰撞体的尺寸，碰撞体的尺寸是有 X 和 Y 两个值的，所以代表它是一个二维的变量，那么我用 Vector2 来创建这几个变量，所以我要先获得它站立的情况下的尺寸和下蹲的尺寸，所以我先获得站立的尺寸，然后我要获得它站立时的坐标，同样我也要定义一个变量，就是它大下蹲的时候，以及下蹲的时候，它的位置。

好有了这些变量之后，接下来我们来看看怎么来用，我们要在一开始就获得我原有的这个方形的碰撞体的尺寸，这样才能保护我们原来的尺寸不被更改，然后我们要在 Start 里面先来获得它，我们要来先来找它的站立的时候的，完整的碰撞体的尺寸，那么应该等于我们方形碰撞体的点儿，size，同样它的位置也是等于它的 Offset 是不是非常的方便。

如果小伙伴们将这个位置不是使用的 BoxCollider，而是使用的 Collider 的话，那么我们不能用 .size 和 .offset 来访问这两个参数的，请小伙伴们留意这个部分，然后我们还需要获得它下蹲的时候的尺寸，下蹲的时候尺寸，我们希望我们的游戏角色的这个碰撞体 Y 轴减半就可以了，所以我们要在一开始 Start 里就把它写好，请小伙伴们留意这里，我是要给它添加一个全新的尺寸的变量，而不是原有的尺寸变量，所以我要在这里用 new Vector2 来进行赋值，所以它的 X 轴是没有变化的，但是 Y 值得会除以 2f，另外，请留意这里不要写错了，在这里我们也同样使用原有碰撞体的 offset 千万要区分开跟这个 size。

好的我们写好了这个部分之后，接下来我们来丰富一下我们的 Crouch 和 StandUp 两个函数，所以当它下蹲的时候，我的现有的碰撞，尺寸就要改成蹲下的时候的尺寸，同样现有的 offset 也要改成蹲下的 offset，那么站立的时候，我们就要恢复原有的站立的尺寸。

好的我们写好了么，这代码了，小伙伴们你看明白了这段代码的意思了嘛，所以我们保存了原有的尺寸，然后也做了一个除以 2f 的尺寸，所以我只要在下蹲和站立的时候来切换，这两个尺寸就可以达到我们想要的效果了，所以回到游戏中试玩一下，好的这个时候，我们选中我们的 Robbie，然后我们打开我们的 BoxCollider，这个时候我们就可以看见我们的 Collider 样子了，然后我们可以左右进行移动，然后当我按下的时候，请小伙伴们注意它的 Collider 变化，看到了吧，它的 Collider 下移了，然后我们就可以通过障碍物了，同时，当我摁住下的时候，我的游戏角色的移动速度也变慢了，所以小伙伴们如果你希望这个下蹲的时候移动速度更慢的话，你可以在 Inspector 的窗口里来修改这个参数。

好的小伙伴们，那我们现在还没有考虑在判断 Crouch 的状态下，如果头上有障碍物，我是不能起立的，所以现在我还没有考虑，但是稍后我们会一起做的，先别着急\~，

---

1.**代码编写前的提示：**

* 强调代码编写的灵活性：

  * 指出代码的实现方式没有绝对的对错，只要功能实现且效果良好即可。
  * 鼓励读者根据自身经验和想法进行创新，提出不同的解决方案。
  * 鼓励读者之间进行代码交流，互相学习，共同进步。
  * 强调学习是一个不断优化的过程。

**2. 角色移动的基础代码：**

* Rigidbody 组件的获取：

  * 通过 `GetComponent` 方法获取角色身上的 Rigidbody 组件，以便控制角色的物理行为。
* 移动参数的设置：

  * 使用 `Header` 属性对代码进行分组，提高代码的可读性和整洁性。
  * 设置角色的移动速度（`Speed`）和下蹲时的速度减缓系数（`crouchSpeedDivisor`）。
  * 使用私有变量 `xVelocity` 存储角色在 X 轴上的移动方向。
* 地面移动的实现：

  * 在 `FixedUpdate` 方法中调用 `GroundMovement` 函数，以确保物理更新的准确性。
  * 通过 `Input.GetAxis("Horizontal")` 获取玩家的水平输入，并赋值给 `xVelocity`。
  * 使用 `rb.velocity` 修改角色的速度，实现水平移动。
* 角色翻转的实现：

  * 创建 `FilpDirction` 函数，根据 `xVelocity` 的正负值翻转角色的 `localScale`，实现角色朝向的改变。
  * 在移动函数中调用翻转函数，达到移动中人物可以正确转向。
* 下蹲功能的实现：

  * 在Unity的project setting中，添加新的input，用于下蹲功能的触发。
  * 添加 `isCrouch` 布尔变量，用于记录角色是否处于下蹲状态。
  * 创建 `Crouch` 和 `StandUp` 函数，分别用于处理角色的下蹲和站立逻辑。
  * 在 `FixedUpdate` 方法中，根据玩家的输入和角色状态调用相应的下蹲或站立函数。
  * 根据角色是否处于下蹲状态，调整角色的移动速度。
  * 通过修改 `BoxCollider2D` 的 `size` 和 `offset` 属性，实现角色下蹲时碰撞体尺寸的改变。
* BoxCollider2D组件的特殊性

  * 当需要特别修改boxcollider2D组件的参数时，声明变量的时候，要使用boxcollider2D类型。

**3. 重要的编程概念：**

* 代码的组织和可读性：

  * 使用 `Header` 属性和注释，使代码更易于理解和维护。
* 物理引擎的使用：

  * 理解 `Rigidbody` 组件和 `FixedUpdate` 方法在物理模拟中的作用。
* 输入系统的使用：

  * 掌握 `Input.GetAxis` 和 `Input.GetButton` 方法，用于获取玩家的输入。
* 碰撞器的控制：

  * 学会如何通过代码修改碰撞器的属性，实现动态的碰撞检测。
* 代码的执行顺序

  * 代码的执行顺序会影响最终的结果，需要特别注意。